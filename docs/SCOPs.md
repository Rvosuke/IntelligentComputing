# 使用EA解决SCOPs

在进化计算领域，越来越多的兴趣集中在将进化算法（EAs）应用于解决SCOPs。由于存在约束，许多约束处理技术已被提出并与EAs集成，因此提出了各种约束优化进化算法（COEAs）。

备注：通过EAs解决SCOPs的目的（**优化过程**）
1) 迅速接近可行区域
2) 最终找到最优解

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240112224742629.png" alt="image-20240112224742629" style="zoom:50%;" />

1. EAs：寻找最优解
2. Constraint-handling techniques：确定父代和子代群体中个体进行比较的标准。

**矛盾：**

1. COEAs为了找到可行的最优解（目标函数）
2. 一些不可行的解决方案可能携带着更重要的信息，用于找到可行的最优解。（约束违背度）

# 约束处理技术

约束处理技术的主要目标是确定比较父代和后代群体中个体的标准。
约束处理技术的核心在于在目标函数和约束违反之间进行权衡。

有三种主要类型的约束处理技术：
1. 基于惩罚函数的方法

2. 基于可行解偏好于不可行解的方法

   个体的比较要么基于目标函数，要么基于惩罚函数，可行解总是在一定程度上被认为比不可行解好。
   缺点：忽略了不可行解的重要信息！

3. 基于多目标优化的方法
   缺点：在约束急剧增加时受到维数灾难的影响！

## 惩罚函数

在约束优化问题中，惩罚函数是一种常用的技术，用于将原始的约束问题转换成无约束问题，使得传统的优化算法能够应用。上传的图片内容介绍了惩罚函数的分析，以下是对每张图片内容的解释和逻辑梳理：

- <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240112221003402.png" alt="image-20240112221003402" style="zoom: 67%;" />引入了一个惩罚项 $r_g G(\vec{x})$ 到目标函数中，这样可以将一个约束优化问题（A）转换成一个无约束优化问题（A'）。
- 提到了在进化算法中动态设置惩罚参数 $r_g$ 的研究工作，包括单调非减序列和自适应方法。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240112221359656.png" alt="image-20240112221359656" style="zoom:50%;" />

描述了惩罚参数 $r_g$ 太大或太小时的后果：$r_g$ 过小可能导致算法无法找到可行解，$r_g$ 过大可能容易找到可行解但质量差。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240112223410162.png" alt="image-20240112223410162" style="zoom:50%;" />

- 介绍了一个基于惩罚函数的个体排序方法，首先根据适应度函数 $\psi(\vec{x}) = f(\vec{x}) + r_g G(\vec{x})$ 对个体进行排序。
- 然后，检查排名相邻的个体对，计算临界惩罚系数 $\tilde{r}_i$，这是决定两个相邻个体排名的关键。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240112223504116.png" alt="image-20240112223504116" style="zoom:50%;" />

- 分析了不同的 $r_g$ 值情况下的三种不同情况，并说明**当比较非支配和可行个体时，$r_g$ 的值对不等式无影响**。

- 对整个种群，选择的 $r_g$ 将决定被目标函数和惩罚函数支配的个体的比例。



定义了最小临界惩罚系数 $\bar{r}_g$ 和最大临界惩罚系数 $\bar{r}_g$。

- 提出了三种情况：$r_g < \bar{r}_g$ 为欠惩罚(所有的比较仅基于目标函数)，$r_g > \bar{r}_g$ 为过惩罚(所有的比较仅基于惩罚函数)，以及两者之间为组合惩罚。
- 强调，既不欠惩罚也不过惩罚是好的约束处理技术。

- 指出 $\bar{r}_g$ 和 $\bar{r}_g$ 不是固定的，而是问题依赖的，并且可能随着代际变化而变化，因为它们由当前种群决定。

## 可行性准则

1. 在两个不可行的解决方案之间，更小的约束违规程度的解决方案被偏好。
2. 如果一个解决方案是不可行的，而另一个是可行的，那么可行解决方案被偏好。
3. 在两个可行的解决方案之间，具有更好目标函数值的解决方案被偏好。



## 随机排序

随机排序（Stochastic Ranking，简称 SR）是一种处理单目标约束优化问题（Single Objective Constrained Optimization Problem，简称 SCOP）中约束的技术。其基本思想是在目标函数值和约束违反度之间找到平衡，以适应那些违反了某些约束但在目标函数上表现良好的解。这种技术在进化算法中尤其有用，因为它可以维持种群多样性并避免过早收敛。

### 随机排序的核心步骤

1. **计算适应度：** 为每个个体计算适应度值 $\psi(\vec{x})$，这个值是目标函数 $f(\vec{x})$ 和所有约束违反度的加权和。这里的 $r_g$ 是一个与违反度相关的参数，$G(\vec{x})$ 表示约束违反函数。
2. **个体排序：** 在种群中对个体进行排序，考虑其目标函数值和约束违反度。排序的过程是自适应的，即根据个体的目标函数值和约束违反度动态调整。
3. **基于排名的选择：** 使用基于排名的选择方法，选择优秀个体进行遗传操作，以生成新的解。

### 随机排序的具体算法

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240112215836932.png" alt="image-20240112215836932" style="zoom:50%;" />

1. **概率参数 $P_f$：** 设置一个概率参数 $P_f$，用于在目标函数值和约束违反度之间进行选择。
2. **相邻个体对比：** 从种群中选择相邻的两个个体 $\vec{x}_1$ 和 $\vec{x}_2$，并比较它们的目标函数值和约束违反度。
   - 如果 $\vec{x}_1$ 在目标函数值上优于 $\vec{x}_2$，则 $\vec{x}_1$ 胜出。
   - 如果 $\vec{x}_1$ 的约束违反度小于 $\vec{x}_2$，则 $\vec{x}_1$ 胜出。
3. 如果个体都是可行解，则只比较目标函数值，否则使用随机数决定。
4. **随机数决定：** 使用一个在0到1之间均匀生成的随机数 $u$ 来决定是否根据 $P_f$ 选择目标函数值或约束违反度来决定胜者。

### 算法伪代码

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240112220116996.png" alt="image-20240112220116996" style="zoom:50%;" />

1. **初始化：** 设置索引 $I_j$ 对应种群中的每个个体。
2. **外层循环：** 对于种群中的每个个体 $\vec{x}_i$，执行内层循环。
3. **内层循环：** 对于每个相邻个体 $\vec{x}_j$ 和 $\vec{x}_{j+1}$：
   - 生成随机数 $u$。
   - 如果 $G(\vec{x}_j)$ 等于0或者 $u < P_f$，并且 $f(\vec{x}_j) > f(\vec{x}_{j+1})$，则交换 $I_j$ 和 $I_{j+1}$。
   - 如果 $G(\vec{x}_j) > G(\vec{x}_{j+1})$，则交换 $I_j$ 和 $I_{j+1}$。
   - 如果在内层循环中没有交换发生，则退出循环。

通过这种方式，随机排序能够在解的目标函数优化和约束满足之间找到一个折衷，允许一定程度的约束违反，同时促进优化过程。这对于那些目标函数与约束之间存在冲突的优化问题特别有用。