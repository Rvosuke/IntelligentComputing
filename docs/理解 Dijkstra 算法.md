## 理解 Dijkstra 算法

Dijkstra 算法主要用于从**单一源节点**到图中**所有其他节点**的**最短路径查找**。该图可以是有向图或无向图，通常表示为由**带权重**的边连接的节点，这些权重表示节点之间的距离或成本。

### 目的和应用

Dijkstra 算法的主要目的是高效地确定从起始节点到带非负权重的加权图中所有其他节点的最短路径。该算法具有很强的通用性，适用于各种实际场景，如：

- **路线优化：** 在 GPS 和导航系统中用于查找物理位置之间的最短路径。
- **网络路由协议：** 在电信中确定通过网络的最佳数据路径至关重要。
- **资源管理：** 有助于优化物流和供应链管理的路线，最小化运输成本和时间。

### 算法细节与实现陷阱

#### 朴素 Dijkstra 算法

朴素 Dijkstra 算法的实现使用一个简单的**数组**来存储从源到所有顶点的最短路径。其工作原理如下：

1. 初始化从源到所有顶点的距离为无穷大，除了源本身为零。
2. 选择具有最小距离的未访问顶点，将其标记为已访问，并更新其相邻顶点的路径长度。
3. 重复直到所有顶点都被访问或未访问顶点中的最小距离为无穷大。

**陷阱：**

- **时间复杂度：** 对于密集图来说，朴素方法可能效率低下，其时间复杂度为 $O(n^2 + m)$，其中 $n$ 是顶点数，$m$ 是边数。
- **实现错误：** 常见错误包括**距离初始化**不正确和未**正确更新距离**。

#### 基于堆的优化 Dijkstra 算法

为了优化 Dijkstra 算法，可以使用优先队列（或二叉堆），通过快速检索具有最短路径的下一个顶点来显著提高效率。该版本与朴素方法类似，但有以下增强：

1. 使用最小堆高效获取具有最小暂定距离的顶点。
2. 从堆中提取最小值，更新相邻顶点的距离，并在距离改进时将其推入堆中。

**陷阱：**

- **复杂的数据结构：** 管理优先队列可能很棘手，尤其是在更新后确保堆属性的维护。
- **边缘情况：** 必须处理所有可能的边缘情况，例如图中有无法从源到达的节点，在计算后这些节点仍可能具有“无穷大”的距离。

### Dijkstra 算法解释

Dijkstra 算法用于查找从源节点到图中所有其他节点的最短路径，适用于边权非负的图。它通过迭代选择距离最小的顶点，更新其邻居的路径长度，并将其标记为“已访问”来操作。

#### 模板分解：

以下是 Dijkstra 算法的 C++ 代码片段分解：

```cpp
int g[N][N];  // 存储每条边
int dist[N];  // 存储1号点到每个点的最短距离
bool st[N];   // 存储每个点的最短路是否已经确定

int dijkstra()
{
    memset(dist, 0x3f, sizeof dist); // 初始化所有距离为无穷大
    dist[1] = 0; // 源节点（节点1）的距离设置为0

    for (int i = 0; i < n - 1; i++) // 循环 n-1 次
    {
        int t = -1; // t 将存储距离最小的节点的索引
        // 找到未访问节点中距离最小的节点
        for (int j = 1; j <= n; j++)
            if (!st[j] && (t == -1 || dist[j] < dist[t]))
                t = j;

        // 标记选中的节点为已访问
        st[t] = true;

        // 更新所有相邻顶点的距离
        for (int j = 1; j <= n; j++)
            dist[j] = min(dist[j], dist[t] + g[t][j]);
    }

    if (dist[n] == 0x3f3f3f3f) return -1; // 如果没有到达节点n的路径
    return dist[n];
}
```

#### 关键组件的解释：

- **图表示**：`int g[N][N]` 用邻接矩阵表示图，其中 `g[i][j]` 存储从节点 `i` 到节点 `j` 的边的权重。如果没有直接连接，通常设置为一个高值（如表示无穷大的 `0x3f3f3f3f`）。
- **距离数组**：`int dist[N]` 存储从源节点（本例中为节点 1）到每个其他节点的已知最短距离。
- **已访问节点**：`bool st[N]` 用于跟踪是否已永久确定节点的最短路径。
- **初始化**：距离初始化为一个非常高的值（无穷大），源节点的距离为 0。
- **找到最小值**：嵌套循环结构首先找到未访问的距离最小的节点 `t`。
- **更新距离**：一旦选择了节点 `t`，就更新到所有其他节点的距离，确保它们表示已知的最短路径。更新考虑通过 `t` 的路径作为潜在的捷径。
- **终止和返回**：循环运行 `n-1` 次，因为每次迭代有一个顶点被确定（其最短路径被永久固定）。在所有迭代之后，如果 `dist[n]`（到最后一个节点的距离）仍为无穷大，表示从节点 1 到节点 n 没有路径。
- **限制**：该算法假设图中**没有负权重边**。如果图中包含负权重边，像 Bellman-Ford 这样的算法更适用。
