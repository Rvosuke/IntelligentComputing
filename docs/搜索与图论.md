# 搜索与图论

## 树和图的存储

理解如何在程序中存储树和图对于有效实现算法至关重要。让我们探索存储图的数据结构，特别是**邻接矩阵**和**邻接表**。这是计算机程序中表示图的两种最常见的方法，每种方法都有其优点和特定的使用场景。

### 1. 邻接矩阵

邻接矩阵是一个二维数组，其中每个单元 $(a, b)$ 表示顶点 $a$ 和顶点 $b$ 之间是否存在边。以下是简要说明：

- **定义：** `int g[N][N];` 声明一个二维数组 `g`，其中 $N$ 是顶点的数量。每个元素 `g[a][b]` 存储一个值，表示从顶点 $a$ 到顶点 $b$ 是否有边，通常也表示该边的权重。
- **用法：** 这种方法简单直接，检查任意两个顶点之间是否存在边很容易——只需查看矩阵值即可。
- **缺点：** 它使用 $O(N^2)$ 空间，对于**稀疏图**（边的数量 $m$ 远小于 $N^2$）来说，这可能非常低效。

#### 示例代码：
```cpp
const int N = 100; // 最大顶点数
int g[N][N]; // 邻接矩阵

// 初始化矩阵为0或无穷大，取决于是否加权
memset(g, 0, sizeof g);

// 添加从节点a到节点b的权重为w的边
g[a][b] = w;

// 添加节点a和节点b之间的无向边
g[a][b] = g[b][a] = w;
```

### 2. 邻接表

邻接表在**表示稀疏图时更节省空间**。它列出了每个顶点相邻的所有顶点。以下是其组件的细分：

- **h[N]：** 这个数组存储描述邻接关系的链表的**头指针**。对于顶点 $k$，`h[k]` 指向包含所有与 $k$ 相邻的顶点的链表头部。
- **e[N]：** 这个数组与 `h` 和 `ne` 一起使用，实际存储**邻接信息**—`e[i]` 表示在列表中第 $i$ 个位置的顶点。
- **ne[N]：** 用于导航链表的“next”数组。如果 `ne[i]` 是 `e` 中的一个索引，那么它指向与 `e[i]` 相同顶点的下一个相邻顶点。
- **idx：** 用于跟踪 `e` 和 `ne` 中下一个空闲位置的索引。

#### 示例代码：
```cpp
const int N = 100010; // 最大顶点数/边数
int h[N], e[N], ne[N], idx;

void add(int a, int b) {
    e[idx] = b;      // b是a的邻接点
    ne[idx] = h[a];  // 当前a的链表头成为下一个元素
    h[a] = idx++;    // 更新a的链表头为新元素
}

void init() {
    memset(h, -1, sizeof h);
    idx = 0; // 初始化idx为0，h中的-1表示尚未初始化的头部
}
```

#### 用法：
- **初始化：** 将 `h` 的所有条目设置为-1，表示没有边。
- **添加边：** 使用 `add` 函数向图中插入边。
- **效率：** 空间复杂度为 $O(n + m)$​，对于稀疏图来说，比邻接矩阵更高效。

让我们分解邻接表表示法的每个组成部分，以澄清其目的和功能：

#### 1. h[N]（头数组）：

- **目的：** 这个数组保存描述邻接关系的链表的头指针。
- **解释：** 对于每个顶点 $k$，`h[k]` 指向包含所有与 $k$ 相邻顶点的链表头部。是的，确实有 $n$ 个不同的链表，每个顶点一个。每个链表针对不同的顶点，表示该顶点的邻接情况。
- **示例：** 如果 `h[1]` 指向一个链表的头部，这意味着顶点 1 的邻居存储在这个链表中。

#### 2. e[N]（边数组）：

- **目的：** 这个数组存储邻接信息。
- **解释：** 每个元素 `e[i]` 代表一个与另一个顶点相邻的顶点。
- **示例：** 如果 `e[3]` 存储值 5，这意味着顶点 3 与顶点 5 相邻。

#### 3. ne[N]（next数组）：

- **目的：** “next”数组帮助导航链表。
- **解释：** 如果 `ne[i]` 是 `e` 中的一个索引，那么它指向与 `e[i]` 相同顶点的下一个相邻顶点。
- **示例：** 如果 `ne[3]` 是 7，这意味着顶点 3 的下一个相邻顶点存储在 `e` 数组的索引 7 处。

#### 4. idx：

- **目的：** 一个索引器，用于跟踪 `e` 和 `ne` 中下一个空闲位置。
- **解释：** 每次向邻接表添加新边时，`idx` 都会递增，确保新边存储在下一个可用位置。
- **示例：** 添加边后，`idx` 递增，以指示数组中的下一个可用位置。

#### 实际实现：

以下是你如何可视化邻接表表示：

- 对于每个顶点 $k$，`h[k]` 指向一个链表的头部。
- 从 `e[h[k]]` 开始的链表中的每个元素代表顶点 $k$ 的一个邻居。
- 顶点 $k$ 的下一个相邻顶点通过 `ne[h[k]]`、`ne[ne[h[k]]]` 等找到。

### 树作为特殊图
树是一种无环且对于 $n$ 个顶点恰好有 $n-1$ 条边的图。树可以使用任何图存储方法表示，但由于没有环，通常使用更简单的结构。

## 树和图的遍历

现在，让我们继续讨论深度优先搜索（DFS）和广度优先搜索（BFS），这是一种基本的图遍历技术。使用你已经学会的邻接表，我们将介绍如何使用模板来进行 DFS 和 BFS。

### 深度优先搜索（DFS）

DFS 是一种递归算法，它在回溯之前**尽可能深入**地探索分支。该方法通常用于探索图的所有顶点和边，特别适用于涉及图的所有连通组件的探索或在两个节点之间寻找路径的问题。

#### DFS 模板的解释：

让我们分解 DFS 函数：

```cpp
int dfs(int u)
{
    st[u] = true; // st[u] 表示点u已经被遍历过

    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j]) dfs(j);
    }
}
```

#### DFS 函数的组成部分：

- **`int dfs(int u)`**：此函数从节点 `u` 开始启动深度优先搜索。
- **`st[u] = true;`**：标记节点 `u` 为已访问。`st[]` 是一个布尔数组，其中 `st[u]` 为 `true` 表示节点 `u` 已被访问，防止图中出现循环和重复访问。
- **`for (int i = h[u]; i != -1; i = ne[i])`**：此循环遍历所有与 `u` 相邻的节点。这里：
  - `i` 从 `h[u]` 开始，即 `u` 在 `e[]` 数组中第一个相邻节点的索引。
  - `ne[i]` 用于找到邻接表中的下一个节点。
- **`int j = e[i];`**：获取与 `u` 在索引 `i` 处相连的节点。
- **`if (!st[j]) dfs(j);`**：如果节点 `j` 未被访问（`!st[j]`），则从 `j` 开始递归地执行 DFS。

#### 使用邻接表的 DFS 工作原理：

假设你有一个用邻接表表示的图，并调用 `dfs(1);`。过程如下：

1. **访问节点 1**：将其标记为已访问。
2. **检查节点 1 的邻接表**：访问邻居列表中的第一个节点。
3. **递归访问每个邻居**：对节点 1 的每个未访问的邻居，调用 `dfs(j)`，其中 `j` 是邻居。继续此过程，直到从节点 1 可达的所有节点都被访问。
4. **回溯**：一旦一个节点的所有邻居都被访问，递归将回溯到前一个节点以探索其他路径。

#### 实际应用：

DFS 特别适用于寻找连通组件、检测循环，以及在有向图和无向图中寻找路径。它还可以扩展用于有向无环图（DAG）的拓扑排序或解决拼图和迷宫问题。

当然！您提供的代码实现了广度优先搜索（BFS），这是另一种基本的图遍历算法。BFS 逐层探索图，先访问节点的所有邻居，然后再移动到下一层。让我们分解您准备的模板：

### 广度优先搜索（BFS）

BFS 通过**系统地**访问与起始顶点固定距离的所有顶点来探索图，然后再移动到距离更远的顶点。它通常用于在**无权图**中找到最短路径。

#### BFS 模板的解释：

```cpp
queue<int> q;
st[1] = true; // 表示1号点已经被遍历过
q.push(1);

while (q.size())
{
    int t = q.front();
    q.pop();

    for (int i = h[t]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true; // 表示点j已经被遍历过
            q.push(j);
        }
    }
}
```

#### BFS 算法的组成部分：

- **`queue<int> q;`**：创建一个**队列**数据结构来存储需要访问的节点。BFS 按照它们被添加到队列的顺序来探索节点，确保从起始点开始访问节点，然后再访问距离更远的节点。
- **`st[1] = true;`**：将起始节点（节点 1）标记为已访问。
- **`q.push(1);`**：将起始节点添加到队列中。
- **`while (q.size())`**：此循环持续**直到队列为空**，表示所有节点已被访问。
- **`int t = q.front(); q.pop();`**：获取并移除队列中的第一个节点。该节点表示当前**正在探索的节点**。
- **`for (int i = h[t]; i != -1; i = ne[i])`**：使用**邻接表遍历**当前节点 `t` 的所有邻居。
- **`int j = e[i];`**：从邻接表中获取与当前节点 `t` 在索引 `i` 处相连的邻居节点 `j`。
- **`if (!st[j]) { st[j] = true; q.push(j); }`**：如果邻居节点 `j` 未被访问（`!st[j]`），则将其标记为已访问并添加到队列中以进一步探索。

#### BFS 的工作原理：

BFS 从起始节点开始，依次探索其所有邻居，然后移动到下一层节点，依次探索它们的所有邻居，以此类推，直到访问所有可达节点。这确保了按照节点与起始点的距离的顺序访问节点，从而实现了对图的广度优先探索。

#### 实际应用：

BFS 用于各种应用，如在无权图中找到最短路径、检查连通性以及解决“水壶问题”或“8数码问题”等拼图。

理解 BFS 对于各种与图相关的问题至关重要，借助这个模板，您可以轻松应用 BFS 解决各种图遍历问题。

我理解你可能会感到有些疲惫——拓扑排序确实是一个比较复杂的话题，但我会尽量使其清晰明了！让我们分解这个模板，并解释拓扑排序是如何工作的。

## 拓扑排序

拓扑排序是一种对**有向图**的顶点进行**线性排序**的算法，使得对于每条有向边 $u \rightarrow v$，顶点 $u$ 在排序中出现在顶点 $v$ 之前。这在任务调度、数据排列以及管理依赖关系的场景中特别有用，在这些场景中，**某些任务必须在其他任务之前**完成。

#### 拓扑排序模板的解释

模板使用 Kahn 算法实现了拓扑排序，这是基于“入度”（一个节点的入边数）概念的方法。

```cpp
bool topsort()
{
    int hh = 0, tt = -1;

    // d[i] 存储节点 i 的入度
    for (int i = 1; i <= n; i++)
        if (!d[i])
            q[++tt] = i; // 入度为 0 的节点加入队列

    while (hh <= tt)
    {
        int t = q[hh++]; // 处理队列中的下一个节点

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (--d[j] == 0) // 减少节点的入度并检查是否变为 0
                q[++tt] = j; // 如果是，则加入队列
        }
    }

    // 如果所有节点都被处理过，则存在拓扑排序；否则，不存在。
    return tt == n - 1;
}
```

#### 模板的关键组件：

- **`int hh = 0, tt = -1;`**：这些变量管理使用数组实现的队列。`hh` 是队列的头，`tt` 是队列的尾。
- **`int d[i];`**：这个数组存储每个顶点的入度。
- **`q[++tt] = i;`**：将入度为零的顶点加入队列。这些顶点没有依赖关系，可以立即处理。
- **`int t = q[hh++];`**：从队列中取出下一个要处理的顶点。
- **`--d[j] == 0`**：当去除一条边后某顶点的入度降为零，表示其所有依赖关系已被处理，现在可以处理该顶点。
- **`return tt == n - 1;`**：检查是否所有顶点都被加入队列（并因此被处理）。如果是，则存在有效的拓扑排序，且图中没有环；否则，图中存在环，无法进行拓扑排序。

#### 使用此模板进行拓扑排序的工作原理：

1. **初始化**：识别所有入度为零的顶点，并将其加入队列。
2. **处理**：不断从队列中取出一个顶点，处理它，并减少其后继顶点的入度。如果后继顶点的入度变为零，则将其加入队列。
3. **环检测**：如果并非所有顶点都被处理（即某些顶点的入度从未降为零），则图中包含环，无法进行拓扑排序。

拓扑排序在解决**依赖关系问题**时至关重要，例如课程安排、项目任务调度等。

